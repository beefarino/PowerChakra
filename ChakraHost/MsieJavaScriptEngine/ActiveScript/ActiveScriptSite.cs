namespace MsieJavaScriptEngine.ActiveScript
{
	using System;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Runtime.InteropServices;
	using System.Globalization;
	using ComTypes = System.Runtime.InteropServices.ComTypes;

	using JsEngines;
	using Resources;

	internal class ActiveScriptSite : IActiveScriptSite, IDisposable
	{
		const string JAVASCRIPT_PROG_ID = "JScript";
		const int TYPE_ERROR_ELEMENT_NOT_FOUND = unchecked((int)(0x8002802B));

		/// <summary>
		/// JS-engine
		/// </summary>
		private IActiveScript _jsEngine;

		/// <summary>
		/// JS-parser
		/// </summary>
		private IActiveScriptParserWrapper _jsParser;

		/// <summary>
		/// JS-dispatcher
		/// </summary>
		private object _jsDispatcher;

		/// <summary>
		/// JS-dispatcher type
		/// </summary>
		private Type _jsDispatcherType;

		private readonly Dictionary<string, object> _siteItems = new Dictionary<string, object>();

		private ActiveScriptException _lastException;

		/// <summary>
		/// Flag that object is destroyed
		/// </summary>
		private bool _disposed;

		/// <summary>
		/// Gets or sets the host-defined document version string
		/// </summary>
		public string DocumentVersion
		{
			get;
			protected set;
		}

		public static bool IsSupported
		{
			get
			{
				return (Type.GetTypeFromProgID(JAVASCRIPT_PROG_ID) != null);
			}
		}


		/// <summary>
		/// Constructs instance of ActiveScriptSiteWrapper
		/// </summary>
		public ActiveScriptSite()
            : this(DateTime.UtcNow.ToString("o")) 
		{ }
		
		/// <summary>
		/// Constructs instance of ActiveScriptSiteWrapper
		/// </summary>
		/// <param name="documentVersion">The host-defined document version string</param>
		public ActiveScriptSite(string documentVersion)
		{
			DocumentVersion = documentVersion;

			try
			{
				// Prefer Chakra
				_jsEngine = new ChakraJsEngine() as IActiveScript;
			}
			catch
			{
				_jsEngine = null;
			}

			if (_jsEngine == null)
			{
				// No need to catch here - engine of last resort
				_jsEngine = new JsEngine() as IActiveScript;
			}

			if (_jsEngine != null)
			{
				_jsEngine.SetScriptSite(this);

				_jsParser = new ActiveScriptParserWrapper(_jsEngine);
				_jsParser.InitNew();
			}

			if (_jsEngine == null)
			{
				throw new JsEngineLoadException(Strings.Runtime_JsEngineNotLoaded);
			}
		}
		
		/// <summary>
		/// Destructs instance of ActiveScriptSiteWrapper
		/// </summary>
		~ActiveScriptSite()
		{
			Dispose(false);
		}


		/// <summary>
		/// Retrieves the locale identifier associated with the host's user interface. The scripting
		/// engine uses the identifier to ensure that error strings and other user-interface elements
		/// generated by the engine appear in the appropriate language.
		/// </summary>
		/// <param name="lcid">A variable that receives the locale identifier for user-interface
		/// elements displayed by the scripting engine</param>
		public void GetLcid(out int lcid)
		{
			lcid = CultureInfo.CurrentCulture.LCID;
		}

		/// <summary>
		/// Allows the scripting engine to obtain information about an item added with the
		/// IActiveScript.AddNamedItem method
		/// </summary>
		/// <param name="name">The name associated with the item, as specified in the
		/// IActiveScript.AddNamedItem method</param>
		/// <param name="returnMask">A bit mask specifying what information about the item should be
		/// returned. The scripting engine should request the minimum amount of information possible
		/// because some of the return parameters (for example, ITypeInfo) can take considerable
		/// time to load or generate</param>
		/// <param name="item">A variable that receives a pointer to the IUnknown interface associated
		/// with the given item. The scripting engine can use the IUnknown.QueryInterface method to
		/// obtain the IDispatch interface for the item. This parameter receives null if returnMask
		/// does not include the ScriptInfo.IUnknown value. Also, it receives null if there is no
		/// object associated with the item name; this mechanism is used to create a simple class when
		/// the named item was added with the ScriptItem.CodeOnly flag set in the
		/// IActiveScript.AddNamedItem method.</param>
		/// <param name="typeInfo">A variable that receives a pointer to the ITypeInfo interface
		/// associated with the item. This parameter receives null if returnMask does not include the
		/// ScriptInfo.ITypeInfo value, or if type information is not available for this item. If type
		/// information is not available, the object cannot source events, and name binding must be
		/// realized with the IDispatch.GetIDsOfNames method. Note that the ITypeInfo interface
		/// retrieved describes the item's coclass (TKIND_COCLASS) because the object may support
		/// multiple interfaces and event interfaces. If the item supports the IProvideMultipleTypeInfo
		/// interface, the ITypeInfo interface retrieved is the same as the index zero ITypeInfo that
		/// would be obtained using the IProvideMultipleTypeInfo.GetInfoOfIndex method.</param>
		public void GetItemInfo(string name, ScriptInfoFlags returnMask, out object item, out IntPtr typeInfo)
		{
			if ((returnMask & ScriptInfoFlags.IUnknown) > 0)
			{
				item = GetItem(name);
				if (item == null)
				{
					throw new COMException(string.Format(Strings.Runtime_ItemNotFound, name), TYPE_ERROR_ELEMENT_NOT_FOUND);
				}
			}
			else
			{
				item = null;
			}

			if ((returnMask & ScriptInfoFlags.ITypeInfo) > 0)
			{
				typeInfo = GetTypeInfo(name);
			}
			else
			{
				typeInfo = IntPtr.Zero;
			}
		}

		/// <summary>
		/// Allows the scripting engine to obtain information about an item added with the
		/// IActiveScript.AddNamedItem method
		/// </summary>
		/// <param name="name">The name associated with the item, as specified in the
		/// IActiveScript.AddNamedItem method</param>
		private object GetItem(string name)
		{
			lock (_siteItems)
			{
				object result;
				return _siteItems.TryGetValue(name, out result) ? result : null;
			}
		}

		/// <summary>
		/// Allows the scripting engine to obtain information about an item added with the
		/// IActiveScript.AddNamedItem method. Gets the COM ITypeInfo
		/// </summary>
		/// <param name="name">The name associated with the item, as specified in the
		/// IActiveScript.AddNamedItem method</param>
		private IntPtr GetTypeInfo(string name)
		{
			lock (_siteItems)
			{
				if (!_siteItems.ContainsKey(name))
				{
					return IntPtr.Zero;
				}

				return Marshal.GetITypeInfoForType(_siteItems[name].GetType());
			}
		}

		/// <summary>
		/// Retrieves a host-defined string that uniquely identifies the current document version. If
		/// the related document has changed outside the scope of Windows Script (as in the case of an
		/// HTML page being edited with Notepad), the scripting engine can save this along with its
		/// persisted state, forcing a recompile the next time the script is loaded.
		/// </summary>
		/// <param name="versionString">The host-defined document version string</param>
		public void GetDocVersionString(out string versionString)
		{
			versionString = DocumentVersion;
		}

		/// <summary>
		/// Gets and resets the last exception. Returns null for none.
		/// </summary>
		private ActiveScriptException GetAndResetLastException()
		{
			var temp = _lastException;
			_lastException = null;

			return temp;
		}

		/// <summary>
		/// Executes a script text
		/// </summary>
		/// <param name="code">Script text</param>
		/// <param name="isExpression">Flag that script text needs to run as an expression</param>
		/// <returns></returns>
		public object ExecuteScriptText(string code, bool isExpression)
		{
			object result;

			try
			{
				result = _jsParser.ParseScriptText(
					code,
					null, null, null, IntPtr.Zero, 0,
					isExpression ? ScriptTextFlags.IsExpression : ScriptTextFlags.IsVisible);
			}
			catch
			{
				var last = GetAndResetLastException();
				if (last != null)
				{
					throw last;
				}
				throw;
			}

			// Check for parse error
			var parseError = GetAndResetLastException();
			if (parseError != null)
			{
				throw parseError;
			}

			UpdateDispatch();

			return result;
		}

		/// <summary>
		/// Calls a function
		/// </summary>
		/// <param name="functionName">Function name</param>
		/// <param name="args">Function arguments</param>
		/// <returns>Result of the function execution</returns>
		public object CallFunction(string functionName, params object[] args)
		{
			object result;
			try
			{
				result = _jsDispatcherType.InvokeMember(functionName, BindingFlags.InvokeMethod, null, _jsDispatcher, args);
			}
			catch
			{
				ThrowError();
				throw;
			}

			ThrowError();

			return result;
		}

		private void UpdateDispatch()
		{
			ComRelease(ref _jsDispatcher);
			_jsEngine.GetScriptDispatch(null, out _jsDispatcher);
			_jsDispatcherType = _jsDispatcher.GetType();
		}

		private void ThrowError()
		{
			var last = GetAndResetLastException();
			if (last != null)
			{
				throw last;
			}
		}

		/// <summary>
		/// Informs the host that the script has completed execution
		/// </summary>
		/// <param name="result">A variable that contains the script result, or null if the script
		/// produced no result</param>
		/// <param name="exceptionInfo">Contains exception information generated when the script
		/// terminated, or null if no exception was generated</param>
		public virtual void OnScriptTerminate(object result, ComTypes.EXCEPINFO exceptionInfo)
		{
		}

		/// <summary>
		/// Informs the host that the scripting engine has changed states
		/// </summary>
		/// <param name="scriptState">Indicates the new script state</param>
		public virtual void OnStateChange(ScriptState scriptState)
		{
		}

		/// <summary>
		/// Informs the host that an execution error occurred while the engine was running the script.
		/// </summary>
		/// <param name="scriptError">A host can use this interface to obtain information about the
		/// execution error</param>
		public void OnScriptError(IActiveScriptError scriptError)
		{
			_lastException = ActiveScriptException.Create(scriptError);
			OnScriptError(_lastException);
		}

		/// <summary>
		/// Informs the host that an execution error occurred while the engine was running the script
		/// </summary>
		/// <param name="exception">The exception</param>
		protected virtual void OnScriptError(ActiveScriptException exception)
		{
		}

		/// <summary>
		/// Informs the host that the scripting engine has begun executing the script code
		/// </summary>
		public virtual void OnEnterScript()
		{
		}

		/// <summary>
		/// Informs the host that the scripting engine has returned from executing script code
		/// </summary>
		public virtual void OnLeaveScript()
		{
		}

		/// <summary>
		/// Destroys object
		/// </summary>
		public void Dispose()
		{
			Dispose(true /* disposing */);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Destroys object
		/// </summary>
		/// <param name="disposing">Flag, allowing destruction of 
		/// managed objects contained in fields of class</param>
		public void Dispose(bool disposing)
		{
			if (!_disposed)
			{
				_disposed = true;

				ComRelease(ref _jsDispatcher, !disposing);

				// For now these next two actually reference 
				// the same object, but it doesn't hurt to be explicit.
				ComRelease(ref _jsParser, !disposing);
				ComRelease(ref _jsEngine, !disposing);
			}
		}

		private void ComRelease<T>(ref T obj, bool final = false)
			where T : class
		{
			if (obj != null && Marshal.IsComObject(obj))
			{
				if (final)
				{
					Marshal.FinalReleaseComObject(obj);
				}
				else
				{
					Marshal.ReleaseComObject(obj);
				}
			}

			obj = null;
		}
	}
}